#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Sat Mar 20 19:36:35 2021

@author: joshua.atienza
"""

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Sat Mar 20 18:49:26 2021

@author: joshua.atienza
"""

import random
import math
import queue
import copy
import time

class Cell:
    
    def __init__(self, index):
        self.index = index

        self.isMine = False

        self.isCovered = True

        self.numMines = 0

        self.SafeSquares = []

        self.numIdMines = []

        self.Hidden = []

        self.Neighbors = []
        
"""
Code for generating the mine field
We create a list of cells, where their associated index correlates to the position in the dxd mine field
"""
def generate_field(d, n):
    
    #Initialize field and count of mines
    field = []
    mine_count = 0
    
    #Add a new cell in the range
    for x in range(d**2):
        cell = Cell(x)
        field.append(cell)
        
    #Randomly generate a mine in a given cell, increase count
    while mine_count < n:
        temp = random.randrange(d**2)
        if(field[temp].isMine == False):
            field[temp].isMine = True
            mine_count = mine_count + 1
    
    #Add information to each cell in the field
    for x in range(d**2):
        neighborinfo = add_knowledge(field, field[x], d)
        field[x].Hidden.extend(field[x].Neighbors)
        
    return field

#Prints the field
def print_field(field,d):
    print("\n")
    total = 0
    for num in range(d):
        for i in range(d):
            if(field[total+i].isMine == True):
                print ("M", end=" ")
            else:
                print ("0", end=" ") #print number
        print("\n")
        total += d
        
"""
Checks the possible moves to make in every direction
Add information about the neighbors of a given cell, and increase number of mines if necessary
"""
def add_knowledge(field, cell, d):
    
    index = cell.index
    dimension = d
    
    #Dictionary of possible cardinal, ordinal directions of mine
    #Initialize them to true
    possibleMoves = {
        
        "north": True,
        "south": True,
        "west": True,
        "east": True,
        "north-west": True,
        "north-east":True,
        "south-west": True,
        "south-east": True
        
    }
    
    # Check for maze boundary conditions
    if (index - dimension < 0): # top edge
        possibleMoves["north"] = False
    if (index + dimension > dimension**2-1): #bottom edge
        possibleMoves["south"] = False
    if (index%dimension == 0): # left edge
        possibleMoves["west"] = False
    if (index%dimension == dimension-1): # right edge
        possibleMoves["east"] = False
    if (possibleMoves["north"] & possibleMoves["west"] == False):
        possibleMoves["north-west"] = False
    if (possibleMoves["north"] & possibleMoves["east"] == False):
        possibleMoves["north-east"] = False
    if (possibleMoves["south"] & possibleMoves["west"] == False):
        possibleMoves["south-west"] = False
    if (possibleMoves["south"] & possibleMoves["east"] == False):
        possibleMoves["south-east"] = False

    for x in possibleMoves.keys():
        
        if(possibleMoves[x] == True):
            if(x=="north"):
                if(field[index-d].isMine == True):
                    cell.numMines += 1
                cell.Neighbors.append(index-d)
            elif(x=="south"):
                if field[index+d].isMine == True:
                    cell.numMines += 1
                cell.Neighbors.append(index+d)
            elif(x=="west"): 
                if field[index-1].isMine == True:
                    cell.numMines += 1
                cell.Neighbors.append(index-1)
            elif(x=="east"):
                if field[index+1].isMine == True:
                    cell.numMines += 1
                cell.Neighbors.append(index+1)
            elif(x=="north-west"):
                if field[index-d-1].isMine == True:
                    cell.numMines += 1
                cell.Neighbors.append(index-d-1)
            elif(x=="north-east"):
                if field[index-d+1].isMine == True:
                    cell.numMines += 1
                cell.Neighbors.append(index-d+1)
            elif(x=="south-west"):
                if field[index+d-1].isMine == True:
                    cell.numMines += 1
                cell.Neighbors.append(index+d-1)
                xyz
            elif(x=="south-east"):
                if field[index+d+1].isMine == True:
                    cell.numMines += 1
                cell.Neighbors.append(index+d+1)  
        
    return possibleMoves 



def simpleAgent(field,dim):
    idmines=[]
    expmines=[]
    safe=[]
    unsearched=[]
    explored=[]
    for x in range(len(field)):
        unsearched.append(field[x].index)
    
    while(len(safe)!=0 or len(unsearched)!=0):      # if there are still safe nodes or unsearched nodes]
        if(len(safe)== 0):                              # path if no more safe nodes
            ranindex=random.randrange(len(unsearched))      # get random index from unsearched and assign to ranindex
            ranspace=field[unsearched[ranindex]]            # use random index to get node
            unsearched.pop(ranindex)                        # remove index from unsearched
            field[ranspace.index].isCovered=False           # reveal the node
            # print("Current Node")
            # print(ranspace.index,"\n",len(unsearched))
        elif(len(safe) > 0):                            # path if still safe nodes
            ranindex=safe.pop(0)                        # get first index on safe list
            ranspace=field[ranindex]                    # use index to get safe node
            unsearched.remove(ranindex)                 # remove safe node from unsearched
            field[ranindex].isCovered=False             # reveal the node
            # print("Current Node")
            # print(ranindex,"\n",len(unsearched))

        if(ranspace.isMine == True):                    # path if node selected from random is a mine
            expmines.append(ranspace.index)             
            for x in range(len(ranspace.Neighbors)):
                field[ranspace.Neighbors[x]].numIdMines.append(ranspace.index)
                field[ranspace.Neighbors[x]].Hidden.remove(ranspace.index)
        #address neighbors when removing
        elif(ranspace.isMine == False):                 # path if node selected is not a mine
            explored.append(ranspace.index)             # add node index to explored
            if(ranspace.numMines - len(ranspace.numIdMines) == len(ranspace.Hidden)): # every node is a mine around it
                for x in range(len(ranspace.Hidden)):   # for all hidden neighbors
                  #  print(ranspace.Hidden)
                    if((ranspace.Hidden[x] not in idmines)):    # if the mine is not ID'd
                        unsearched.remove(ranspace.Hidden[x])   # remove mine from unsearched
                        idmines.append(ranspace.Hidden[x])      # append mine to ID mines
                    minedetect(field,field[ranspace.Hidden[x]]) # pass neighbor into mine detect - mine detect tells all the mines neighbors, its been ID'd
                    for y in range(len(field)):                 # for all nodes in the field - remove ranspace node from hidden node list of each node
                        if ranspace.Hidden[x] in field[y].Hidden and y!=ranspace.index:
                            field[y].Hidden.remove(ranspace.Hidden[x])
                ranspace.Hidden.clear() # no more hidden nodes in ranspace
            elif(len(ranspace.Neighbors)-ranspace.numMines-len(ranspace.SafeSquares)==len(ranspace.Hidden)): # every node is safe around it
                for x in range(len(ranspace.Hidden)):       # for all hidden neighbors
                    if(ranspace.Hidden[x] not in safe):         # if neighbor index is not in safe
                        safe.append(ranspace.Hidden[x])         # add neighbor index to safe
                ranspace.Hidden.clear()                     # remove all neighbors from node's hidden
            for x in range(len(ranspace.Neighbors)):        # for all neighbors
                if(ranspace not in field[ranspace.Neighbors[x]].SafeSquares):
                    field[ranspace.Neighbors[x]].SafeSquares.append(ranspace)   # append original node to all neighbors safe spaces
                if len(field[ranspace.Neighbors[x]].Hidden) != 0:           # for all neighbors, remove original node from their hidden
                    if(ranspace.index in field[ranspace.Neighbors[x]].Hidden):
                        field[ranspace.Neighbors[x]].Hidden.remove(ranspace.index)
        print("Unsearched")
        for x in range(len(unsearched)):
            print(unsearched[x])
        print("safe")
        print(safe) 
        print("IdedMines")
        print(idmines)
        print('Exploded mines')
        print(expmines)
        print("Explored")
        print(explored)   
        print("current status")
        print_field(field, 3)
    return len(idmines)


def minedetect(field,node):
    for x in range(len(node.Neighbors)):
        field[node.Neighbors[x]].numIdMines.append(node.index)
def tilesolved(field,node):
    if(len(field[node].Neighbors)-field[node].numMines-len(field[node].SafeSquares)==len(field[node].Hidden)):
        return True
    elif(field[node].numMines - len(field[node].numIdMines) == len(field[node].Hidden)):
        return True
    else:
        return False

def main():

    mazefield =[]
    dim=3
    mineTotal=3
    iterations=1
    advanced= []
    simple=[]
    mines=[]
    t=time.time()
    for x in range(iterations):
        mazefield = generate_field(dim,mineTotal)
        mazefieldCopy = copy.deepcopy(mazefield)
        mazefieldMineCount=copy.deepcopy(mazefield)
        minesdetected=simpleAgent(mazefield,dim)

if __name__ == "__main__":
    main()
